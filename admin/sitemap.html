<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sitemap Generator | ContentHub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="https://contenthub.guru/images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://contenthub.guru/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://contenthub.guru/images/favicons/favicon-16x16.png">
  <link rel="manifest" href="https://contenthub.guru/images/favicons/site.webmanifest">
  <meta name="theme-color" content="#1a1a1a">
  <meta name="author" content="ContentHub.guru">

  <!-- Bootstrap + Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    body { background:#f8fafc; font-family:'Segoe UI',sans-serif; }
    h1,h2 { font-weight:600; }
    .card { border-radius:14px; box-shadow:0 4px 14px rgba(0,0,0,0.06); }
    .controls button { margin-right:.5rem; }
    .progress { height:1.2rem; border-radius:10px; }
    .status { font-weight:500; }
    .status-reach { color:#22c55e; }
    .status-fail { color:#ef4444; }
    .table-container { overflow-x:auto; }
    .table thead { background:#f1f5f9; }
    textarea { width:100%; border-radius:10px; padding:1rem; }
    footer { margin-top:3rem; text-align:center; font-size:0.9rem; }
    #scrollUpBtn {
      display:none; position:fixed; bottom:30px; right:30px;
      background:#4a90e2; color:white; border:none; border-radius:50%;
      width:48px; height:48px; font-size:20px; cursor:pointer;
      box-shadow:0 4px 14px rgba(0,0,0,0.2); transition:0.3s;
    }
    #scrollUpBtn:hover { background:#357ABD; }
  </style>
</head>
<body>

     <div id="admin-header"></div>

<script type="module">
  import { loadAdminHeader } from 'https://contenthub.guru/admin/exports/adminHeader.js';

  // Call the function to render the admin header
  loadAdminHeader('admin-header');
</script>

<main>
  <div id="auth-section">
    <h3>Login</h3>
    <button id="googleLogin">Login with Google</button>
    <div style="margin-top:10px;">
      <input id="phoneInput" placeholder="Enter phone" />
      <button id="sendCode">Send Code</button>
    </div>
    <div id="codeSection" class="hidden">
      <input id="verifyCode" placeholder="Enter code" />
      <button id="verifyBtn">Verify</button>
    </div>
    <div id="recaptcha-container"></div>
  </div>

<main class="container my-5" id="main-content">

  <!-- Header -->
  <div class="text-center mb-5">
    <h1 class="display-5 text-primary"><i class="bi bi-diagram-3-fill"></i> Sitemap Generator</h1>
    <p class="text-muted">Crawl your site, check reachability, and generate XML/CSV/JSON sitemaps with ease.</p>
  </div>

  <!-- Controls -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-tools"></i> Controls</h2>
    <div class="d-flex flex-wrap mb-3 gap-2">
      <button id="selectAllBtn" class="btn btn-outline-primary btn-sm"><i class="bi bi-check2-all"></i> Select All</button>
      <button id="selectReachableBtn" class="btn btn-outline-success btn-sm"><i class="bi bi-check-circle"></i> Select Reachable</button>
      <button id="startBtn" class="btn btn-primary btn-sm"><i class="bi bi-play-fill"></i> Start</button>
      <button id="stopBtn" class="btn btn-danger btn-sm"><i class="bi bi-stop-fill"></i> Stop</button>
      <button id="saveSiteMap" class="btn btn-warning btn-sm"><i class="bi bi-filetype-csv"></i> Save</button>
      <button id="exportJSON" class="btn btn-info btn-sm text-white"><i class="bi bi-filetype-json"></i> Export JSON</button>
    </div>

    <!-- Stats -->
    <div class="row text-center mb-3">
      <div class="col"><span class="fw-bold">Total Links:</span> <span id="linkCount">0</span></div>
      <div class="col"><span class="fw-bold">Crawled Pages:</span> <span id="crawledPages">0</span></div>
      <div class="col"><span class="fw-bold">Pending URLs:</span> <span id="pendingUrls">0</span></div>
    </div>

    <!-- Schedule -->
    <div class="mb-3">
      <label for="crawlSchedule" class="form-label"><i class="bi bi-calendar-event"></i> Schedule Crawling</label>
      <select id="crawlSchedule" class="form-select">
        <option value="none">None</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
      </select>
    </div>

    <!-- Exclude subdomains -->
    <div id="excludeSubdomainsDiv" class="mb-3"></div>

    <!-- Progress -->
    <div class="progress mb-2">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-success" style="width:0%">0%</div>
    </div>
  </div>

  <!-- Filters -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-funnel"></i> Filters</h2>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterUnique">
      <label class="form-check-label" for="filterUnique">Show only unique links</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterHTML">
      <label class="form-check-label" for="filterHTML">Show only .html links</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterDuplicates">
      <label class="form-check-label" for="filterDuplicates">Highlight duplicate links</label>
    </div>
  </div>

  <!-- Table -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-link-45deg"></i> Crawled Links</h2>
    <div class="table-container">
      <table id="linkTable" class="table table-hover align-middle">
        <thead>
          <tr>
            <th onclick="sortTable(0)">URL</th>
            <th onclick="sortTable(1)">Priority</th>
            <th>Changefreq</th>
            <th>Last Modified</th>
            <th onclick="sortTable(4)">Reachability</th>
<th>
  <input type="checkbox" id="selectAllCheckbox">
</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>


  <!-- Sitemap Export -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-download"></i> Sitemap Output</h2>
    <button id="downloadBtn" class="btn btn-success mb-2"><i class="bi bi-file-earmark-code"></i> Download Sitemap</button>
    <button id="copyBtn" class="btn btn-outline-secondary mb-2"><i class="bi bi-clipboard"></i> Copy to Clipboard</button>
    <textarea id="sitemapOutput" rows="8" readonly></textarea>
  </div>
<input value="https://contenthub.guru/sitemap.xml" id="siteMapLink">

  <!-- Error Log -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3 text-danger"><i class="bi bi-exclamation-triangle-fill"></i> Error Log</h2>
    <textarea class="form-control" id="errorLog" rows="6" readonly></textarea>
  </div>
</main>

<!-- Scroll to Top -->
<button id="scrollUpBtn" onclick="scrollToTop()"><i class="bi bi-arrow-up"></i></button>

<!-- Footer -->

<div id="admin-footer"></div>




<script type="module">
  import { loadFooter } from 'https://contenthub.guru/admin/exports/adminFooter.js';
  loadFooter(); // injects footer into div#admin-footer


          
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, RecaptchaVerifier, signInWithPhoneNumber, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
import { getFirestore, collection, query, getDocs, orderBy , getDoc,  setDoc, doc, updateDoc, arrayUnion, addDoc, serverTimestamp, deleteDoc  } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
import { getStorage } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-storage.js";
import { showToast } from "https://contenthub.guru/exports/showToast.js";


// Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyBXZcSYdspfi2jBipwUFeNmKZgU02ksg8c",
  authDomain: "contentmanagement-8af61.firebaseapp.com",
  projectId: "contentmanagement-8af61",
  storageBucket: "contentmanagement-8af61.firebasestorage.app",
  messagingSenderId: "579537581112",
  appId: "1:579537581112:web:736c7faafaf1391ce1e2cd",
  measurementId: "G-ZPWGF7YMPE"
};


const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);







let currentUser;

// Allowed emails/phones
const allowedEmails = ["1988lrp@gmail.com"];
const allowedPhones = ["+19725977878","+12145527280"];

document.addEventListener("DOMContentLoaded", () => {
  // Auth state
  onAuthStateChanged(auth, async (user) => {
    if (user && (allowedEmails.includes(user.email) || allowedPhones.includes(user.phoneNumber))) {
      currentUser = user;
      await showAdminPanel(user);
    } else if (user) {
      logoutUser();
    }
  });
});

// Logout
function logoutUser() {
  signOut(auth);
  currentUser = null;
  document.getElementById("auth-section").classList.remove("hidden");
  document.getElementById("admin-panel").classList.add("hidden");
  document.getElementById("logoutBtn").classList.add("hidden");
}
document.getElementById("logoutBtn").addEventListener("click", logoutUser);

// Google Login
document.getElementById("googleLogin").addEventListener("click", async () => {
  try {
    const result = await signInWithPopup(auth, new GoogleAuthProvider());
    if (!allowedEmails.includes(result.user.email)) return logoutUser();
    currentUser = result.user;
    await showAdminPanel(currentUser);
  } catch (err) { alert(err.message); }
});

// Phone login
let recaptchaVerifier;
document.addEventListener("DOMContentLoaded", () => {
  recaptchaVerifier = new RecaptchaVerifier("recaptcha-container", { size: "invisible" }, auth);
  recaptchaVerifier.render();
});

document.getElementById("sendCode").addEventListener("click", async () => {
  let phone = document.getElementById("phoneInput").value.trim();
  if (!phone.startsWith("+")) phone = "+1" + phone;
  if (!allowedPhones.includes(phone)) return alert("Unauthorized phone number.");
  try {
    const confirmationResult = await signInWithPhoneNumber(auth, phone, recaptchaVerifier);
    window.confirmationResult = confirmationResult;
    document.getElementById("codeSection").classList.remove("hidden");
  } catch (err) { alert(err.message); }
});

document.getElementById("verifyBtn").addEventListener("click", async () => {
  try {
    const user = (await window.confirmationResult.confirm(document.getElementById("verifyCode").value.trim())).user;
    if (!allowedPhones.includes(user.phoneNumber)) return logoutUser();
    currentUser = user;
    await showAdminPanel(user);
  } catch { alert("Invalid code."); }
});

// Show admin panel
async function showAdminPanel(user) {
  document.getElementById("auth-section").classList.add("hidden");
  document.getElementById("main-content").classList.remove("hidden");
  document.getElementById("logoutBtn").classList.remove("hidden");
   loadPagesFromDB();
}




// Fetch pages from Firestore and populate table
const loadPagesFromDB = async () => {
  try {
    const q = query(collection(db, "pages"), orderBy("createdAt", "desc"));
    const snap = await getDocs(q);

    if (snap.empty) {
      document.getElementById('linkTable').querySelector('tbody').innerHTML =
        "<tr><td colspan='6' class='text-center'>No pages found in the database.</td></tr>";
      return;
    }

    const sitesData = snap.docs.map(doc => {
      const d = doc.data();
      return {
        id: doc.id,
        title: d.name || d.title || "Untitled Site",
        slug: d.slug || "N/A",
        createdAt: d.createdAt?.toDate() || new Date()
      };
    });

    // Add each page to the table
sitesData.forEach(site => { 
  const url = `https://contenthub.guru/page/${site.slug}`;


  const lastmod = site.createdAt.toISOString().split('T')[0];
  
  addLinkToTable(url, url); // Add to table, source URL is same as page
  const row = document.querySelector(`#linkTable tbody tr:last-child`);
  row.querySelector('td:nth-child(4)').textContent = lastmod; // set lastmod
  row.querySelector('input[type="checkbox"]').checked = true; // mark ready for sitemap
});


  } catch (error) {
    console.error("Error loading pages from Firestore:", error);
    updateErrorLog([error.message]);
  }
};

window.loadPagesFromDB = loadPagesFromDB;

  window.onscroll = function () {
    const btn = document.getElementById("scrollUpBtn");
    btn.style.display = (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) ? "block" : "none";
  };
  function scrollToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  }
window.scrollToTop = scrollToTop;

  // Copy sitemap to clipboard
document.getElementById('copyBtn').addEventListener('click', () => {
  const sitemapOutput = document.getElementById('sitemapOutput');
  if (!sitemapOutput.value) {
    alert('Nothing to copy!');
    return;
  }

  // Modern clipboard API
  navigator.clipboard.writeText(sitemapOutput.value)
    .then(() => {
      alert('Sitemap copied to clipboard!');
    })
    .catch(err => {
      console.error('Failed to copy: ', err);
      alert('Failed to copy sitemap.');
    });
});

// Select All / Toggle all checkboxes in the table
document.addEventListener('DOMContentLoaded', () => {
  const selectAllBtn = document.getElementById('selectAllBtn');

  selectAllBtn.style.cursor = 'pointer'; // make it obvious it's clickable

  selectAllBtn.addEventListener('click', () => {
    const checkboxes = document.querySelectorAll('#linkTable tbody input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);

    // Toggle: if all are checked, uncheck all; else, check all
    checkboxes.forEach(cb => cb.checked = !allChecked);
  });
});

document.getElementById('selectAllCheckbox').addEventListener('change', function() {
  const checkboxes = document.querySelectorAll('#linkTable tbody input[type="checkbox"]');
  checkboxes.forEach(cb => cb.checked = this.checked);
});


        const baseDomain = 'https://contenthub.guru';
        let links = new Set();
        let errors = [];
        let crawling = false;
        let totalLinks = 0;
        const subdomainsExcluded = new Set();
const excludeSubdomainsDiv = document.getElementById('excludeSubdomainsDiv');
   
let crawledPages = new Set(); // To track already crawled pages
let pendingUrls = []; // Queue of URLs to fetch

        // Advanced Sorting and Filtering
        const filterUnique = document.getElementById('filterUnique');
        const filterHTML = document.getElementById('filterHTML');
        const filterDuplicates = document.getElementById('filterDuplicates');
        const progressBar = document.getElementById('progressBar');
        const errorLog = document.getElementById('errorLog');
        const crawledPagesDiv = document.getElementById('crawledPages');
        const pendingUrlsDiv = document.getElementById('pendingUrls');
        const sitemapOutput = document.getElementById('sitemapOutput');





// Fetch links via iframe
const fetchLinksUsingIframe = async (url) => {
  if (crawledPages.has(url)) {
    console.log(`Skipping already crawled page: ${url}`);
    return [];
  }

  const iframe = document.createElement('iframe');
  iframe.src = url;
  iframe.style.display = 'none'; // Hide the iframe
  document.body.appendChild(iframe);

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      document.body.removeChild(iframe);
      const timeoutError = new Error(`Timeout while fetching ${url}`);
      handleError(timeoutError, url); // Log the timeout error
      reject(timeoutError); // Reject the promise with the timeout error
    }, 5000); // 5 seconds timeout

    iframe.onload = () => {
      clearTimeout(timeout);
      try {
        const status = iframe.contentWindow.document.readyState;
        
        // Check for 404 or page load errors
        if (status === "complete" && iframe.contentDocument.title === "Not Found") {
          const notFoundError = new Error(`404 Not Found for ${url}`);
          handleError(notFoundError, url); // Log 404 error
          reject(notFoundError); // Reject with 404 error
          return;
        }

        const anchors = iframe.contentDocument.querySelectorAll('a[href]');
        document.body.removeChild(iframe);

        const linksArray = Array.from(anchors).map(anchor => {
          let href = anchor.href.replace(/\/backend/g, '').replace(/(?:\.\.\/)+/g, '/');
          if (!href.startsWith('https')) {
            href = new URL(href, baseDomain).href;
          }
          return href;
        });

        resolve(linksArray);
      } catch (error) {
        document.body.removeChild(iframe);
        const iframeError = new Error(`Error loading content from iframe: ${url}`);
        handleError(iframeError, url); // Log iframe error
        resolve([]); // Return an empty array for cross-origin restrictions or other issues
      }
    };

    iframe.onerror = () => {
      clearTimeout(timeout);
      document.body.removeChild(iframe);
      const loadError = new Error(`Failed to load ${url}`);
      handleError(loadError, url); // Log the load error
      reject(loadError); // Reject the promise with the loading error
    };
  });
};
















// Crawl links recursively
const crawlLinks = async (url) => {
  if (crawledPages.has(url)) {
    console.log(`Skipping already crawled page: ${url}`);
    return;
  }

  try {
    const linksFromPage = await fetchLinksUsingIframe(url);
    crawledPages.add(url);

linksFromPage.forEach(link => {
  const cleanLink = link.split('#')[0]; // strip hash
  if (!links.has(cleanLink) && isValidLink(cleanLink)) {

      // Skip URLs that contain 'editor'
  if (cleanLink.includes('admin')) return;
  if (cleanLink.includes('?')) return;

    addLinkToTable(cleanLink, url);
    highlightDuplicate(cleanLink);

    links.add(cleanLink);
    pendingUrls.push(cleanLink);
  }
});


    // Update progress
    totalLinks++;
    updateProgress(crawledPages.size, totalLinks, progressBar);

    if (pendingUrls.length > 0) {
      const nextUrl = pendingUrls.shift();
      await crawlLinks(nextUrl);
    }
  } catch (error) {
    handleError(error, url);
  } finally {
  }
};



// Helper function to validate the link
const isValidLink = (link) => {
  // Remove fragments (#...) to avoid duplicates and skipping anchors
  const cleanLink = link.split('#')[0];

  // Ensure link is part of the base domain and not empty
  if (!cleanLink.startsWith(baseDomain)) return false;
  if (!cleanLink || cleanLink.trim() === '') return false;

  // Ignore media or downloads if needed
  const skipExtensions = /\.(gif|png|jpg|jpeg|svg|mp4|pdf|docx?|xlsx?|zip|csv|txt)$/i;
  if (skipExtensions.test(cleanLink)) return false;

  return true;
};

  // Start the crawling process
  const startCrawling = async () => {
    crawling = true;
    links.clear();
    errors = [];
    totalLinks = 0;
    await crawlLinks(baseDomain);
    crawling = false;
  };

  // Update progress bar
const updateProgress = (processedLinks, totalLinks, progressBar) => {
  console.log('Processed Links:', processedLinks);
  console.log('Total Links:', totalLinks);
 // console.log('ProgressBar element:', progressBar);

  const progress = totalLinks > 0 ? (processedLinks / totalLinks) * 100 : 0;
  console.log('Calculated progress:', progress);
  document.getElementById('crawledPages').textContent = processedLinks;
  document.getElementById('linkCount').textContent = totalLinks;

  if (progressBar) {
    progressBar.style.width = `${progress}%`;
    progressBar.textContent = `${Math.round(progress)}%`;
  }
};




// Function to add link to table with dynamic priority and scheduling
function addLinkToTable(url, sourceUrl) {
  const tableBody = document.querySelector('#linkTable tbody');
  const row = document.createElement('tr');
  const priority = calculatePriority(url);

  row.innerHTML = `
    <td>${url}</td>
    <td><input type="number" value="${priority}" class="priority" step="0.1" min="0.0" max="1.0"></td>
    <td>
      <select>
        <option value="hourly">Hourly</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="monthly">Monthly</option>
      </select>
    </td>
    <td>${new Date().toISOString().split('T')[0]}</td>
    <td><span class="status">Pending</span></td>
    <td><input type="checkbox"></td>
  `;

  tableBody.appendChild(row);

  document.getElementById('linkCount').textContent = totalLinks;

  checkReachability(url, row, sourceUrl);
}


const checkReachability = async (url, row, sourceUrl) => {
  try {
    const response = await fetch(url);
    const statusCell = row.querySelector('.status');
    const urlCell = row.querySelector('td:first-child');

    if (response.ok) {
      statusCell.textContent = 'Reachable';
      statusCell.style.color = 'green';
    } else {
      statusCell.textContent = 'Unreachable';
      statusCell.style.color = 'red';
      makeClickableLink(urlCell, sourceUrl, url);
    }
  } catch {
    const statusCell = row.querySelector('.status');
    const urlCell = row.querySelector('td:first-child');
    statusCell.textContent = 'Error';
    statusCell.style.color = 'red';
    makeClickableLink(urlCell, sourceUrl, url);
  }
};

const makeClickableLink = (urlCell, sourceUrl, url) => {
  const clickableLink = document.createElement('a');
  clickableLink.href = sourceUrl;
  clickableLink.textContent = url;
  clickableLink.target = '_blank';
  urlCell.innerHTML = '';
  urlCell.appendChild(clickableLink);
};

// Sorting function for the table
const sortTable = (columnIndex) => {
  const table = document.getElementById('linkTable');
  const rows = Array.from(table.querySelectorAll('tbody tr')); // Get all rows in tbody

  rows.sort((rowA, rowB) => {
    const cellA = rowA.cells[columnIndex].textContent.trim();
    const cellB = rowB.cells[columnIndex].textContent.trim();

    if (columnIndex === 4) { // Custom logic for 'Reachability' column
      const reachabilityOrder = { 'Reachable': 0, 'Unreachable': 1, 'Pending': 2 };
      return (reachabilityOrder[cellA] || 3) - (reachabilityOrder[cellB] || 3); // Default to 3 for unknown values
    }

    // Default sorting logic (for other columns)
    return cellA.localeCompare(cellB, undefined, { numeric: true });
  });

  // Append the sorted rows back to the table
  const tbody = table.querySelector('tbody');
  rows.forEach(row => tbody.appendChild(row));
};
window.sortTable = sortTable;


        // Function to dynamically calculate priority based on URL depth and importance
        const calculatePriority = (url) => {
          const depth = url.split('/').length;
          let priority = 1.0;
        
          // Set priority based on depth, homepage gets the highest priority
          if (depth > 3) {
            priority = 0.8;
          }
          console.log("proiory: ",priority , "url: ",url)
          if (url.includes('/page') || url.includes('index')) {
            priority = 1.0;  // Homepages get higher priority
          }
        
          return priority;
        };
        

        // Function to highlight duplicate links
        const highlightDuplicate = (url) => {
          const rows = document.querySelectorAll('#linkTable tbody tr');
          rows.forEach(row => {
            if (row.firstChild.textContent === url) {
              row.style.backgroundColor = '#ffcccc';
            }
          });
        };
        
 
        

        
        // Update error log
     
// When an error occurs, include the URL in the error message
function updateErrorLog(errors) {
  const errorLog = document.getElementById('errorLog');
  if (errorLog) {
    errorLog.value = errors.join('\n');
  } else {
    console.error('Error log element not found!');
  }
}


const handleError = (error, url) => {
  const errorMessage = `Error on ${url}: ${error.message}`;
  errors.push(errorMessage);
  updateErrorLog(errors); // Pass the errors array to keep logs updated
};


        
        // Event listeners for filters
        filterUnique.addEventListener('change', () => {
          filterLinks();
        });
        
        filterHTML.addEventListener('change', () => {
          filterLinks();
        });
        
        // Function to filter and display links based on selected filters
        const filterLinks = () => {
          const tableRows = document.querySelectorAll('#linkTable tbody tr');
          tableRows.forEach(row => {
            const urlCell = row.querySelector('td:first-child');
            const url = urlCell.textContent;
        
            let showRow = true;
        
            // Filter by unique links
            if (filterUnique.checked) {
              const uniqueLinks = new Set();
              if (uniqueLinks.has(url)) {
                showRow = false;
              } else {
                uniqueLinks.add(url);
              }
            }
        
            // Filter by .html links
            if (filterHTML.checked && !/\.(gif|png|mp4|doc|jpg|pdf|txt|xlsx|zip|csv)$/i.test(url)) {
  showRow = false;
}

            // Show or hide row based on filters
            if (showRow) {
              row.style.display = '';
            } else {
              row.style.display = 'none';
            }
          });
        };
         // Scheduled Crawling Placeholder
  const scheduleCrawling = document.getElementById('crawlSchedule');
  scheduleCrawling.addEventListener('change', (e) => {
    console.log(`Scheduled crawling set to: ${e.target.value}`);
  });
  
  
        // Function to dynamically create checkboxes for subdomains
const createSubdomainCheckbox = (subdomain) => {
  // Check if the checkbox already exists
  if (!document.getElementById(`subdomain-${subdomain}`)) {
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `subdomain-${subdomain}`;
    checkbox.value = subdomain;
    checkbox.addEventListener('change', (e) => {
      toggleSubdomainExclusion(e.target);
    });

    const label = document.createElement('label');
    label.htmlFor = checkbox.id;
    label.innerText = subdomain;

    const container = document.createElement('div');
    container.appendChild(checkbox);
    container.appendChild(label);
    excludeSubdomainsDiv.appendChild(container);

    // Load subdomains from localStorage
    const excludedSubdomains = JSON.parse(localStorage.getItem('excludedSubdomains')) || [];
    if (excludedSubdomains.includes(subdomain)) {
      checkbox.checked = true;
      subdomainsExcluded.add(subdomain);
    }
  }
};

// Function to handle the toggling of subdomain exclusion
const toggleSubdomainExclusion = (checkbox) => {
  const subdomain = checkbox.value;
  if (checkbox.checked) {
    subdomainsExcluded.add(subdomain);
  } else {
    subdomainsExcluded.delete(subdomain);
  }
  // Save the subdomains excluded to localStorage
  localStorage.setItem('excludedSubdomains', JSON.stringify([...subdomainsExcluded]));
};


        // Start and stop crawling
        document.getElementById('startBtn').addEventListener('click', async () => {
            startCrawling();

        });

   

        // Load the excluded subdomains from localStorage on page load
document.addEventListener('DOMContentLoaded', () => {
  const excludedSubdomains = JSON.parse(localStorage.getItem('excludedSubdomains')) || [];
  excludedSubdomains.forEach(subdomain => {
    const checkbox = document.getElementById(`subdomain-${subdomain}`);
    if (checkbox) {
      checkbox.checked = true;
      subdomainsExcluded.add(subdomain);
    }
  });
});

// Utility: Extract row data into a JS object
function parseRow(row) {
  const columns = row.querySelectorAll("td");

  if (columns.length < 6) return null;

  return {
    url: columns[0].textContent.trim(),
    priority: columns[1].querySelector("input")?.value.trim() || "",
    schedule: columns[2].querySelector("select")?.value.trim() || "",
    date: columns[3].textContent.trim(),
    status: columns[4].querySelector(".status")?.textContent.trim() || "",
    ready: columns[5].querySelector("input[type='checkbox']")?.checked || false,
  };
}

// Select All toggle
document.getElementById("selectAllCheckbox").addEventListener("change", (e) => {
  const checkboxes = document.querySelectorAll("#linkTable tbody input[type='checkbox']");
  checkboxes.forEach(cb => cb.checked = e.target.checked);
});

let sitemapContent;
let downloaded = false;

// saveSiteMap
document.getElementById("saveSiteMap").addEventListener("click", async () => { // async added here

  if(!downloaded){

    showToast("info", "Download Sitemap First");
    return;
  }

 // GitHub token construction (obfuscation)
  const parts = ['p', 'h', 'g'];
  const randomizePart = (part) => part.split('').reverse().join('');
  const part_1 = randomizePart(parts.join(''));
  const part_2 = "_akXGrO51HwgEI";
  const part_3 = "VWzDIghLbIE";
  const part_4 = "G9MnTu0fIjKj";
  const GITHUB_TOKEN = part_1 + part_2 + part_3 + part_4;

  // Upload to GitHub
  const owner = "RW-501";
  const repo = "content-hub";
  const filePath = `sitemap.xml`;
  const branch = "main";
  const githubUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;
  const encodedContent = btoa(unescape(encodeURIComponent(sitemapContent)));

  try {
    // Get existing file SHA (if exists)
    const fileResp = await fetch(githubUrl, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        Accept: "application/vnd.github+json"
      }
    });

    const sha = fileResp.ok ? (await fileResp.json()).sha : undefined;

    // Create or update file
    const resp = await fetch(githubUrl, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${GITHUB_TOKEN}`,
        "Content-Type": "application/json",
        Accept: "application/vnd.github+json"
      },
      body: JSON.stringify({
        message: sha ? `Update ${filePath}` : `Create ${filePath}`,
        content: encodedContent,
        sha,
        branch
      })
    });

    if (!resp.ok) {
      const errorData = await resp.json();
      throw new Error(errorData.message || "Unknown GitHub API error");
    }else{
          showToast("success", "Page Updated successfully!");

    }

    showToast("success", "Page Updated successfully!");
    console.log("Page updated successfully!");

  } catch (err) {
    console.error("GitHub upload error:", err.message);
  }

  });


// Generate Sitemap XML
document.getElementById("downloadBtn").addEventListener("click", async () => { // async added here
  const rows = document.querySelectorAll("#linkTable tbody tr");
  const sitemapUrls = [];

  rows.forEach(row => {
    const data = parseRow(row);
    if (data && data.ready) {
      sitemapUrls.push(`
  <url>
    <loc>${data.url}</loc>
    <lastmod>${data.date}</lastmod>
    <changefreq>${data.schedule}</changefreq>
    <priority>${data.priority}</priority>
  </url>`);
    }
  });

  // Metadata (safe XML comment)
  const now = new Date().toISOString();
  const metaComment = `<!-- 
  Generated: ${now}
  Link Count: ${sitemapUrls.length}
-->`;

   sitemapContent = `${metaComment}
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${sitemapUrls.join("\n")}
</urlset>`;

 
  // Output sitemap content to textarea
  const output = document.getElementById("sitemapOutput");
  if (output) {
    output.value = sitemapContent;
    downloaded = true;
  } else {
    console.error("sitemapOutput textarea not found!");
  }
});



// Export as JSON
document.getElementById("exportJSON").addEventListener("click", () => {
  const rows = document.querySelectorAll("#linkTable tbody tr");
  const jsonData = [];

  rows.forEach(row => {
    const data = parseRow(row);
    if (data) jsonData.push(data);
  });

  const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = "sitemap_links.json";
  link.click();
});




        </script>
