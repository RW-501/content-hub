<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sitemap Generator | ContentHub</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap + Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    body { background:#f8fafc; font-family:'Segoe UI',sans-serif; }
    h1,h2 { font-weight:600; }
    .card { border-radius:14px; box-shadow:0 4px 14px rgba(0,0,0,0.06); }
    .controls button { margin-right:.5rem; }
    .progress { height:1.2rem; border-radius:10px; }
    .status { font-weight:500; }
    .status-reach { color:#22c55e; }
    .status-fail { color:#ef4444; }
    .table-container { overflow-x:auto; }
    .table thead { background:#f1f5f9; }
    textarea { width:100%; border-radius:10px; padding:1rem; }
    footer { margin-top:3rem; text-align:center; font-size:0.9rem; }
    #scrollUpBtn {
      display:none; position:fixed; bottom:30px; right:30px;
      background:#4a90e2; color:white; border:none; border-radius:50%;
      width:48px; height:48px; font-size:20px; cursor:pointer;
      box-shadow:0 4px 14px rgba(0,0,0,0.2); transition:0.3s;
    }
    #scrollUpBtn:hover { background:#357ABD; }
  </style>
</head>
<body>

     <div id="admin-header"></div>

<script type="module">
  import { loadAdminHeader } from 'https://contenthub.guru/admin/exports/adminHeader.js';

  // Call the function to render the admin header
  loadAdminHeader('admin-header');
</script>

<main class="container my-5" id="main-content">

  <!-- Header -->
  <div class="text-center mb-5">
    <h1 class="display-5 text-primary"><i class="bi bi-diagram-3-fill"></i> Sitemap Generator</h1>
    <p class="text-muted">Crawl your site, check reachability, and generate XML/CSV/JSON sitemaps with ease.</p>
  </div>

  <!-- Controls -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-tools"></i> Controls</h2>
    <div class="d-flex flex-wrap mb-3 gap-2">
      <button id="selectAllBtn" class="btn btn-outline-primary btn-sm"><i class="bi bi-check2-all"></i> Select All</button>
      <button id="selectReachableBtn" class="btn btn-outline-success btn-sm"><i class="bi bi-check-circle"></i> Select Reachable</button>
      <button id="startBtn" class="btn btn-primary btn-sm"><i class="bi bi-play-fill"></i> Start</button>
      <button id="stopBtn" class="btn btn-danger btn-sm"><i class="bi bi-stop-fill"></i> Stop</button>
      <button id="exportCSV" class="btn btn-warning btn-sm"><i class="bi bi-filetype-csv"></i> Export CSV</button>
      <button id="exportJSON" class="btn btn-info btn-sm text-white"><i class="bi bi-filetype-json"></i> Export JSON</button>
    </div>

    <!-- Stats -->
    <div class="row text-center mb-3">
      <div class="col"><span class="fw-bold">Total Links:</span> <span id="linkCount">0</span></div>
      <div class="col"><span class="fw-bold">Crawled Pages:</span> <span id="crawledPages">0</span></div>
      <div class="col"><span class="fw-bold">Pending URLs:</span> <span id="pendingUrls">0</span></div>
    </div>

    <!-- Schedule -->
    <div class="mb-3">
      <label for="crawlSchedule" class="form-label"><i class="bi bi-calendar-event"></i> Schedule Crawling</label>
      <select id="crawlSchedule" class="form-select">
        <option value="none">None</option>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
      </select>
    </div>

    <!-- Exclude subdomains -->
    <div id="excludeSubdomainsDiv" class="mb-3"></div>

    <!-- Progress -->
    <div class="progress mb-2">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-success" style="width:0%">0%</div>
    </div>
  </div>

  <!-- Filters -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-funnel"></i> Filters</h2>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterUnique">
      <label class="form-check-label" for="filterUnique">Show only unique links</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterHTML">
      <label class="form-check-label" for="filterHTML">Show only .html links</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="filterDuplicates">
      <label class="form-check-label" for="filterDuplicates">Highlight duplicate links</label>
    </div>
  </div>

  <!-- Table -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-link-45deg"></i> Crawled Links</h2>
    <div class="table-container">
      <table id="linkTable" class="table table-hover align-middle">
        <thead>
          <tr>
            <th onclick="sortTable(0)">URL</th>
            <th onclick="sortTable(1)">Priority</th>
            <th>Changefreq</th>
            <th>Last Modified</th>
            <th onclick="sortTable(4)">Reachability</th>
<th>
  <input type="checkbox" id="selectAllCheckbox">
</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>


  <!-- Sitemap Export -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3"><i class="bi bi-download"></i> Sitemap Output</h2>
    <button id="downloadBtn" class="btn btn-success mb-2"><i class="bi bi-file-earmark-code"></i> Download Sitemap</button>
    <button id="copyBtn" class="btn btn-outline-secondary mb-2"><i class="bi bi-clipboard"></i> Copy to Clipboard</button>
    <textarea id="sitemapOutput" rows="8" readonly></textarea>
  </div>

  <!-- Error Log -->
  <div class="card p-4 mb-4">
    <h2 class="h5 mb-3 text-danger"><i class="bi bi-exclamation-triangle-fill"></i> Error Log</h2>
    <textarea class="form-control" id="errorLog" rows="6" readonly></textarea>
  </div>
</main>

<!-- Scroll to Top -->
<button id="scrollUpBtn" onclick="scrollToTop()"><i class="bi bi-arrow-up"></i></button>

<!-- Footer -->

<div id="admin-footer"></div>
<script type="module">
  import { loadFooter } from 'https://contenthub.guru/admin/exports/adminFooter.js';
  loadFooter(); // injects footer into div#admin-footer
</script>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>

  window.onscroll = function () {
    const btn = document.getElementById("scrollUpBtn");
    btn.style.display = (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) ? "block" : "none";
  };
  function scrollToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  }

  // Copy sitemap to clipboard
document.getElementById('copyBtn').addEventListener('click', () => {
  const sitemapOutput = document.getElementById('sitemapOutput');
  if (!sitemapOutput.value) {
    alert('Nothing to copy!');
    return;
  }

  // Modern clipboard API
  navigator.clipboard.writeText(sitemapOutput.value)
    .then(() => {
      alert('Sitemap copied to clipboard!');
    })
    .catch(err => {
      console.error('Failed to copy: ', err);
      alert('Failed to copy sitemap.');
    });
});

// Select All / Toggle all checkboxes in the table
document.addEventListener('DOMContentLoaded', () => {
  const selectAllBtn = document.getElementById('selectAllBtn');

  selectAllBtn.style.cursor = 'pointer'; // make it obvious it's clickable

  selectAllBtn.addEventListener('click', () => {
    const checkboxes = document.querySelectorAll('#linkTable tbody input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);

    // Toggle: if all are checked, uncheck all; else, check all
    checkboxes.forEach(cb => cb.checked = !allChecked);
  });
});

document.getElementById('selectAllCheckbox').addEventListener('change', function() {
  const checkboxes = document.querySelectorAll('#linkTable tbody input[type="checkbox"]');
  checkboxes.forEach(cb => cb.checked = this.checked);
});

</script>



        <script>
        const baseDomain = 'https://contenthub.guru';
        let links = new Set();
        let errors = [];
        let crawling = false;
        let totalLinks = 0;
        const subdomainsExcluded = new Set();
const excludeSubdomainsDiv = document.getElementById('excludeSubdomainsDiv');
   
let crawledPages = new Set(); // To track already crawled pages
let pendingUrls = []; // Queue of URLs to fetch

        // Advanced Sorting and Filtering
        const filterUnique = document.getElementById('filterUnique');
        const filterHTML = document.getElementById('filterHTML');
        const filterDuplicates = document.getElementById('filterDuplicates');
        const progressBar = document.getElementById('progressBar');
        const errorLog = document.getElementById('errorLog');
        const crawledPagesDiv = document.getElementById('crawledPages');
        const pendingUrlsDiv = document.getElementById('pendingUrls');
        const sitemapOutput = document.getElementById('sitemapOutput');

        

// Fetch links via iframe
const fetchLinksUsingIframe = async (url) => {
  if (crawledPages.has(url)) {
    console.log(`Skipping already crawled page: ${url}`);
    return [];
  }

  const iframe = document.createElement('iframe');
  iframe.src = url;
  iframe.style.display = 'none'; // Hide the iframe
  document.body.appendChild(iframe);

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      document.body.removeChild(iframe);
      const timeoutError = new Error(`Timeout while fetching ${url}`);
      handleError(timeoutError, url); // Log the timeout error
      reject(timeoutError); // Reject the promise with the timeout error
    }, 5000); // 5 seconds timeout

    iframe.onload = () => {
      clearTimeout(timeout);
      try {
        const status = iframe.contentWindow.document.readyState;
        
        // Check for 404 or page load errors
        if (status === "complete" && iframe.contentDocument.title === "Not Found") {
          const notFoundError = new Error(`404 Not Found for ${url}`);
          handleError(notFoundError, url); // Log 404 error
          reject(notFoundError); // Reject with 404 error
          return;
        }

        const anchors = iframe.contentDocument.querySelectorAll('a[href]');
        document.body.removeChild(iframe);

        const linksArray = Array.from(anchors).map(anchor => {
          let href = anchor.href.replace(/\/backend/g, '').replace(/(?:\.\.\/)+/g, '/');
          if (!href.startsWith('https')) {
            href = new URL(href, baseDomain).href;
          }
          return href;
        });

        resolve(linksArray);
      } catch (error) {
        document.body.removeChild(iframe);
        const iframeError = new Error(`Error loading content from iframe: ${url}`);
        handleError(iframeError, url); // Log iframe error
        resolve([]); // Return an empty array for cross-origin restrictions or other issues
      }
    };

    iframe.onerror = () => {
      clearTimeout(timeout);
      document.body.removeChild(iframe);
      const loadError = new Error(`Failed to load ${url}`);
      handleError(loadError, url); // Log the load error
      reject(loadError); // Reject the promise with the loading error
    };
  });
};
















// Crawl links recursively
const crawlLinks = async (url) => {
  if (crawledPages.has(url)) {
    console.log(`Skipping already crawled page: ${url}`);
    return;
  }

  try {
    const linksFromPage = await fetchLinksUsingIframe(url);
    crawledPages.add(url);

    linksFromPage.forEach(link => {
      if (!links.has(link) && link.startsWith(baseDomain)) {
        // Ensure the link is valid before adding it
        if (!isValidLink(link)) {
          console.log(`Skipping invalid link: ${link}`);
          return;
        }

        addLinkToTable(link, url);
        highlightDuplicate(link); 

        links.add(link);
        pendingUrls.push(link);
      }
    });

    // Update progress
    totalLinks++;
    updateProgress(crawledPages.size, totalLinks, progressBar);

    if (pendingUrls.length > 0) {
      const nextUrl = pendingUrls.shift();
      await crawlLinks(nextUrl);
    }
  } catch (error) {
    handleError(error, url);
  } finally {
  }
};

// Helper function to validate the link
const isValidLink = (link) => {
  // Logic to check if the link is valid, could be as simple as ensuring it doesn't return a 404
  return !link.includes("404") && link.includes(baseDomain);
};

  // Start the crawling process
  const startCrawling = async () => {
    crawling = true;
    links.clear();
    errors = [];
    totalLinks = 0;
    await crawlLinks(baseDomain);
    crawling = false;
  };

  // Update progress bar
const updateProgress = (processedLinks, totalLinks, progressBar) => {
  console.log('Processed Links:', processedLinks);
  console.log('Total Links:', totalLinks);
 // console.log('ProgressBar element:', progressBar);

  const progress = totalLinks > 0 ? (processedLinks / totalLinks) * 100 : 0;
  console.log('Calculated progress:', progress);
  document.getElementById('crawledPages').textContent = processedLinks;
  document.getElementById('linkCount').textContent = totalLinks;

  if (progressBar) {
    progressBar.style.width = `${progress}%`;
    progressBar.textContent = `${Math.round(progress)}%`;
  }
};




// Function to add link to table with dynamic priority and scheduling
const addLinkToTable = (url, sourceUrl) => {
  const tableBody = document.querySelector('#linkTable tbody');
  const row = document.createElement('tr');
  const priority = calculatePriority(url);

  row.innerHTML = `
    <td>${url}</td>
    <td><input type="number" value="${priority}" class="priority" step="0.1" min="0.0" max="1.0"></td>
    <td>
      <select>
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="monthly">Monthly</option>
      </select>
    </td>
    <td>${new Date().toISOString().split('T')[0]}</td>
    <td><span class="status">Pending</span></td>
    <td><input type="checkbox"></td>
  `;

  tableBody.appendChild(row);

  document.getElementById('linkCount').textContent = totalLinks;

  checkReachability(url, row, sourceUrl);
};

const checkReachability = async (url, row, sourceUrl) => {
  try {
    const response = await fetch(url);
    const statusCell = row.querySelector('.status');
    const urlCell = row.querySelector('td:first-child');

    if (response.ok) {
      statusCell.textContent = 'Reachable';
      statusCell.style.color = 'green';
    } else {
      statusCell.textContent = 'Unreachable';
      statusCell.style.color = 'red';
      makeClickableLink(urlCell, sourceUrl, url);
    }
  } catch {
    const statusCell = row.querySelector('.status');
    const urlCell = row.querySelector('td:first-child');
    statusCell.textContent = 'Error';
    statusCell.style.color = 'red';
    makeClickableLink(urlCell, sourceUrl, url);
  }
};

const makeClickableLink = (urlCell, sourceUrl, url) => {
  const clickableLink = document.createElement('a');
  clickableLink.href = sourceUrl;
  clickableLink.textContent = url;
  clickableLink.target = '_blank';
  urlCell.innerHTML = '';
  urlCell.appendChild(clickableLink);
};

// Sorting function for the table
const sortTable = (columnIndex) => {
  const table = document.getElementById('linkTable');
  const rows = Array.from(table.querySelectorAll('tbody tr')); // Get all rows in tbody

  rows.sort((rowA, rowB) => {
    const cellA = rowA.cells[columnIndex].textContent.trim();
    const cellB = rowB.cells[columnIndex].textContent.trim();

    if (columnIndex === 4) { // Custom logic for 'Reachability' column
      const reachabilityOrder = { 'Reachable': 0, 'Unreachable': 1, 'Pending': 2 };
      return (reachabilityOrder[cellA] || 3) - (reachabilityOrder[cellB] || 3); // Default to 3 for unknown values
    }

    // Default sorting logic (for other columns)
    return cellA.localeCompare(cellB, undefined, { numeric: true });
  });

  // Append the sorted rows back to the table
  const tbody = table.querySelector('tbody');
  rows.forEach(row => tbody.appendChild(row));
};
window.sortTable = sortTable;


        // Function to dynamically calculate priority based on URL depth and importance
        const calculatePriority = (url) => {
          const depth = url.split('/').length;
          let priority = 1.0;
        
          // Set priority based on depth, homepage gets the highest priority
          if (depth > 3) {
            priority = 0.5;
          }
          if (url.includes('/jobs') || url.includes('index')) {
            priority = 1.0;  // Homepages get higher priority
          }
        
          return priority;
        };
        

        // Function to highlight duplicate links
        const highlightDuplicate = (url) => {
          const rows = document.querySelectorAll('#linkTable tbody tr');
          rows.forEach(row => {
            if (row.firstChild.textContent === url) {
              row.style.backgroundColor = '#ffcccc';
            }
          });
        };
        
 
        

        
        // Update error log
     
// When an error occurs, include the URL in the error message
const updateErrorLog = (errors) => {
  const errorLog = document.getElementById('errorLog');
  if (errorLog) {
    errorLog.value = errors.join('\n');
  } else {
    console.error('Error log element not found!');
  }
};

const handleError = (error, url) => {
  const errorMessage = `Error on ${url}: ${error.message}`;
  errors.push(errorMessage);
  updateErrorLog(errors); // Pass the errors array to keep logs updated
};


        
        // Event listeners for filters
        filterUnique.addEventListener('change', () => {
          filterLinks();
        });
        
        filterHTML.addEventListener('change', () => {
          filterLinks();
        });
        
        // Function to filter and display links based on selected filters
        const filterLinks = () => {
          const tableRows = document.querySelectorAll('#linkTable tbody tr');
          tableRows.forEach(row => {
            const urlCell = row.querySelector('td:first-child');
            const url = urlCell.textContent;
        
            let showRow = true;
        
            // Filter by unique links
            if (filterUnique.checked) {
              const uniqueLinks = new Set();
              if (uniqueLinks.has(url)) {
                showRow = false;
              } else {
                uniqueLinks.add(url);
              }
            }
        
            // Filter by .html links
            if (filterHTML.checked && !/\.(gif|png|mp4|doc|jpg|pdf|txt|xlsx|zip|csv)$/i.test(url)) {
  showRow = false;
}

            // Show or hide row based on filters
            if (showRow) {
              row.style.display = '';
            } else {
              row.style.display = 'none';
            }
          });
        };
         // Scheduled Crawling Placeholder
  const scheduleCrawling = document.getElementById('crawlSchedule');
  scheduleCrawling.addEventListener('change', (e) => {
    console.log(`Scheduled crawling set to: ${e.target.value}`);
  });
  
  
        // Function to dynamically create checkboxes for subdomains
const createSubdomainCheckbox = (subdomain) => {
  // Check if the checkbox already exists
  if (!document.getElementById(`subdomain-${subdomain}`)) {
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `subdomain-${subdomain}`;
    checkbox.value = subdomain;
    checkbox.addEventListener('change', (e) => {
      toggleSubdomainExclusion(e.target);
    });

    const label = document.createElement('label');
    label.htmlFor = checkbox.id;
    label.innerText = subdomain;

    const container = document.createElement('div');
    container.appendChild(checkbox);
    container.appendChild(label);
    excludeSubdomainsDiv.appendChild(container);

    // Load subdomains from localStorage
    const excludedSubdomains = JSON.parse(localStorage.getItem('excludedSubdomains')) || [];
    if (excludedSubdomains.includes(subdomain)) {
      checkbox.checked = true;
      subdomainsExcluded.add(subdomain);
    }
  }
};

// Function to handle the toggling of subdomain exclusion
const toggleSubdomainExclusion = (checkbox) => {
  const subdomain = checkbox.value;
  if (checkbox.checked) {
    subdomainsExcluded.add(subdomain);
  } else {
    subdomainsExcluded.delete(subdomain);
  }
  // Save the subdomains excluded to localStorage
  localStorage.setItem('excludedSubdomains', JSON.stringify([...subdomainsExcluded]));
};


        // Start and stop crawling
        document.getElementById('startBtn').addEventListener('click', async () => {
            startCrawling();

        });

   

        // Load the excluded subdomains from localStorage on page load
document.addEventListener('DOMContentLoaded', () => {
  const excludedSubdomains = JSON.parse(localStorage.getItem('excludedSubdomains')) || [];
  excludedSubdomains.forEach(subdomain => {
    const checkbox = document.getElementById(`subdomain-${subdomain}`);
    if (checkbox) {
      checkbox.checked = true;
      subdomainsExcluded.add(subdomain);
    }
  });
});


document.getElementById('selectAllBtn').addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('#linkTable input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(checkbox => checkbox.checked);
  
  // Toggle the selection of all checkboxes
  checkboxes.forEach(checkbox => {
    checkbox.checked = !allChecked;
  });
});

document.getElementById('downloadBtn').addEventListener('click', () => {

  // Call the generateSitemap function when the button is clicked
  generateSitemap();
});

// Function to generate sitemap and populate the textarea
const generateSitemap = async () => { 
  const rows = document.querySelectorAll('#linkTable tbody tr');
  const sitemapUrls = [];

  // Loop through each row in the table to extract link data
  rows.forEach(row => {
    const columns = row.querySelectorAll('td');
    
    // Ensure there are enough columns to prevent errors
    if (columns.length >= 6) {
      // Extract the URL, priority, schedule, date, and ready status from each row
      const linkData = {
        url: columns[0].textContent.trim(),
        priority: columns[1].textContent.trim(),
        schedule: columns[2].querySelector('select').value.trim(), // Get schedule value from dropdown
        date: columns[3].textContent.trim(),
        ready: columns[5].querySelector('input').checked, // Get checkbox status
      };

      // Only add ready URLs to the sitemap
      if (linkData.ready) {
        // Format the data in the sitemap XML format
        const urlEntry = `<url>
          <loc>${linkData.url}</loc>
          <lastmod>${linkData.date}</lastmod>
          <changefreq>${linkData.schedule}</changefreq>
          <priority>${linkData.priority}</priority>
        </url>`;
        sitemapUrls.push(urlEntry);
      }
    }
  });

  // Wrap the URLs in <urlset> tags as per sitemap structure
  const sitemapContent = `<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n${sitemapUrls.join('\n')}\n</urlset>`;

  // Populate the sitemapOutput textarea with the generated sitemap content
  const sitemapOutput = document.getElementById('sitemapOutput');
  if (sitemapOutput) {
    sitemapOutput.value = sitemapContent;
  } else {
    console.error('sitemapOutput textarea not found!');
  }
};


// Export as CSV
document.getElementById('exportCSV').addEventListener('click', () => {
  const rows = document.querySelectorAll('#linkTable tbody tr');
  const csvData = [];

  // Add header row
  csvData.push('URL,Priority,ChangeFreq,LastMod');

  // Loop through table rows and extract data
  rows.forEach(row => {
    const columns = row.querySelectorAll('td');
    const url = columns[0].textContent.trim();
    const priority = columns[1].textContent.trim();
    const changeFreq = columns[2].textContent.trim();
    const lastMod = columns[3].textContent.trim();

    // Add row data in the correct format
    csvData.push(`"${url}","${priority}","${changeFreq}","${lastMod}"`);
  });

  // Create CSV Blob and download
  const csvBlob = new Blob([csvData.join('\n')], { type: 'text/csv' });
  const csvUrl = URL.createObjectURL(csvBlob);
  const csvLink = document.createElement('a');
  csvLink.href = csvUrl;
  csvLink.download = 'sitemap_links.csv';
  csvLink.click();
});

// Export as JSON
document.getElementById('exportJSON').addEventListener('click', () => {
  const rows = document.querySelectorAll('#linkTable tbody tr');
  const jsonData = [];

  // Loop through table rows and extract data
  rows.forEach(row => {
    const columns = row.querySelectorAll('td');
    const linkData = {
      url: columns[0].textContent.trim(),
      priority: columns[1].textContent.trim(),
      schedule: columns[2].textContent.trim(),
      date: columns[3].textContent.trim(),
    };
    jsonData.push(linkData);
  });

  // Create JSON Blob and download
  const jsonBlob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
  const jsonUrl = URL.createObjectURL(jsonBlob);
  const jsonLink = document.createElement('a');
  jsonLink.href = jsonUrl;
  jsonLink.download = 'sitemap_links.json';
  jsonLink.click();
});







        </script>
