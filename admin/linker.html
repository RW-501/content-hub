<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auto Link Admin (Improved)</title>
  <link rel="apple-touch-icon" sizes="180x180" href="https://contenthub.guru/images/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://contenthub.guru/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://contenthub.guru/images/favicons/favicon-16x16.png">
  <meta name="theme-color" content="#1a1a1a">
  <meta name="author" content="ContentHub.guru">

  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin:0; padding:0; background:#f4f6f8; color:#333; }
    h2,h3 { color:#357ABD; margin:0 0 0.5rem 0; }
    main { max-width:1200px; margin:2rem auto; padding:0 1rem; }
    .card { margin:10px 0;padding:12px;border:1px solid #ccc;background:#fff;border-radius:8px; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
    button { cursor:pointer; border:none; border-radius:6px; padding:0.45rem 0.8rem; background:#4a90e2; color:white; font-weight:600; transition:0.18s; }
    button.ghost { background:transparent; color:#357ABD; border:1px solid #357ABD; }
    button.danger { background:#e05a5a; }
    button:hover { transform:translateY(-1px); opacity:0.95; }
    input, textarea, select { padding:0.5rem; margin:0.3rem 0; border-radius:6px; border:1px solid #ccc; }
    #keywordModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; }
    #keywordModalContent { background: #fff; padding: 20px; width: 560px; max-height: 80%; overflow: auto; border-radius: 8px; }
    .keyword-item { display:flex; justify-content:space-between; gap:8px; align-items:center; padding:6px 0; border-bottom:1px dashed #eee; }
    #linkLog { margin-top: 10px; max-height: 300px; overflow: auto; font-size: 13px; border: 1px solid #ddd; padding: 8px; background:#fff; border-radius:6px; }
    #linkStats { margin-top: 8px; font-size: 14px; }
    #previewContainer { display:flex; gap:12px; margin-top:10px; }
    .preview { flex:1; background:#fafafa; border:1px solid #eee; padding:8px; border-radius:6px; max-height:200px; overflow:auto; font-size:14px; }
    mark.test-link { background: yellow; padding:0 2px; border-radius:2px; }
    a.inserted-link { background: #fffced; padding:0 2px; border-radius:2px; text-decoration:underline; }
    label.small { font-size:13px; color:#666; display:block; margin-top:6px; }
  </style>
</head>
<body>

<div id="admin-header"></div>
<script type="module">
  import { loadAdminHeader } from 'https://contenthub.guru/admin/exports/adminHeader.js';
  // try/catch so page still loads if header module fails
  try { loadAdminHeader('admin-header'); } catch (e) { console.warn('Header load failed', e); }
</script>

<main>
  <h2>üîó Auto Link Admin ‚Äî Improved</h2>

  <div class="card">
    <div class="controls">
      <button onclick="startAutoLink()">‚ñ∂ Start All Pages</button>
      <button onclick="stopAutoLink()">‚èπ Stop</button>
      <button onclick="skipKeyword()" class="ghost">‚è≠ Skip Keyword</button>
      <button onclick="toggleTestMode()" class="ghost">üîÄ Toggle Test Mode</button>
      <button onclick="openKeywordModal()" class="ghost">üìù Manage Keywords</button>
      <button onclick="clearLog()" class="ghost">üßπ Clear Log</button>
    </div>

    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
      <input id="pageIdInput" placeholder="Enter page ID..." style="padding:6px;width:260px;">
      <button onclick="updateCurrentPage()">üìÑ Update Current Page</button>

      <label style="margin-left:8px;">
        <span class="small">Per-block limit</span>
        <input id="perBlockLimit" type="number" min="1" max="10" value="2" style="width:70px;margin-left:6px;padding:6px;">
      </label>

      <label>
        <span class="small">Link density factor (words ‚Üí links)</span>
        <input id="densityFactor" type="number" min="50" max="1000" value="150" style="width:90px;margin-left:6px;padding:6px;">
      </label>
    </div>

    <div id="linkStats">
      Test Mode: <span id="testModeStatus">ON</span> |
      Current Page: <span id="currentPage">None</span> |
      Words: <span id="statWords">0</span> |
      Max Links: <span id="statMax">0</span> |
      Inserted: <span id="statInserted">0</span>
    </div>

    <div style="margin-top:10px;">
      <strong>Keywords to link:</strong>
      <ul id="keywordsList"></ul>
    </div>

    <div id="previewContainer">
      <div class="preview" id="previewBefore"><strong>Before (first changed paragraph)</strong><div id="previewBeforeInner" style="margin-top:6px;"><em>‚Äî</em></div></div>
      <div class="preview" id="previewAfter"><strong>After (with links/highlights)</strong><div id="previewAfterInner" style="margin-top:6px;"><em>‚Äî</em></div></div>
    </div>
  </div>

  <div id="linkLog" class="card"><em>Log will appear here...</em></div>
</main>

<div id="keywordModal">
  <div id="keywordModalContent">
    <h3>Manage Keywords</h3>
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
      <input id="newKeyword" placeholder="Keyword..." style="flex:1;padding:6px;">
      <input id="newSlug" placeholder="Slug..." style="width:240px;padding:6px;">
      <button onclick="addKeyword()">‚ûï Add</button>
    </div>
    <div id="modalKeywordList" style="max-height:320px;overflow:auto;"></div>
    <div style="text-align:right;margin-top:10px;">
      <button onclick="closeKeywordModal()">Close</button>
    </div>
  </div>
</div>

<div id="admin-footer"></div>
<script type="module">
  import { loadFooter } from 'https://contenthub.guru/admin/exports/adminFooter.js';
  try { loadFooter(); } catch (e) { console.warn('Footer load failed', e); }
</script>

<script type="module">
/* ============================
   FIREBASE (same imports you had)
   ============================ */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getFirestore, collection, doc, getDoc, getDocs, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBXZcSYdspfi2jBipwUFeNmKZgU02ksg8c",
  authDomain: "contentmanagement-8af61.firebaseapp.com",
  projectId: "contentmanagement-8af61",
  storageBucket: "contentmanagement-8af61.firebasestorage.app",
  messagingSenderId: "579537581112",
  appId: "1:579537581112:web:736c7faafaf1391ce1e2cd",
  measurementId: "G-ZPWGF7YMPE"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ============================
   Global State
   ============================ */
let autoLinkRunning = false;
let keywordsArray = []; // {keyword, slug}
let maxLinks = 0;
let insertedLinks = 0;
let processedPages = 0;
let testMode = true; // default
let firstPreviewShown = false;

/* ============================
   Helpers + UI
   ============================ */
function el(id){ return document.getElementById(id); }
function log(msg){
  const elLog = el('linkLog');
  const time = new Date().toLocaleTimeString();
  elLog.innerHTML += `<div>[${time}] ${msg}</div>`;
  elLog.scrollTop = elLog.scrollHeight;
}
function clearLog(){ el('linkLog').innerHTML = `<em>Log cleared</em>`; }

function updateKeywordDisplay(){
  const ul = el('keywordsList'); ul.innerHTML = '';
  keywordsArray.forEach(k=>{
    const li = document.createElement('li');
    li.textContent = `${k.keyword} ‚Üí https://contenthub.guru/page/${k.slug}`;
    ul.appendChild(li);
  });
  el('testModeStatus').innerText = testMode ? 'ON' : 'OFF';
  updateStatsUI();
}

function updateStatsUI(words=0){
  el('statWords').innerText = words;
  el('statMax').innerText = maxLinks;
  el('statInserted').innerText = insertedLinks;
}

/* ============================
   Load keywords from Firestore
   ============================ */
async function loadKeywords(){
  try{
    const snap = await getDocs(collection(db,'keywords'));
    keywordsArray = [];
    snap.forEach(s=>{
      const data = s.data();
      if(!data.removed && data.keyword && data.slug) keywordsArray.push({keyword:data.keyword, slug:data.slug});
    });
    // Sort keywords by length desc so multi-word/longer keywords match first
    keywordsArray.sort((a,b)=>b.keyword.length - a.keyword.length);
    updateKeywordDisplay();
    renderModalList();
    log(`Loaded ${keywordsArray.length} keywords.`);
  }catch(e){
    console.error(e); log('Error loading keywords: '+e.message);
  }
}
window.addEventListener('load', loadKeywords);

/* ============================
   Keyword Modal UI
   ============================ */
function openKeywordModal(){ el('keywordModal').style.display='flex'; renderModalList(); }
function closeKeywordModal(){ el('keywordModal').style.display='none'; }

function renderModalList(){
  const container = el('modalKeywordList'); container.innerHTML='';
  keywordsArray.forEach((k,i)=>{
    const div = document.createElement('div');
    div.className = 'keyword-item';
    div.innerHTML = `<div style="flex:1"><strong>${escapeHtml(k.keyword)}</strong> ‚Üí <span style="color:#357ABD">/site/${escapeHtml(k.slug)}</span></div>
                     <div style="display:flex;gap:8px">
                      <button onclick="removeKeyword(${i})" class="danger">‚ùå</button>
                     </div>`;
    container.appendChild(div);
  });
}

async function addKeyword(){
  const kw = el('newKeyword').value.trim();
  const slug = el('newSlug').value.trim();
  if(!kw || !slug) return alert('Enter both keyword and slug');
  // prevent dup slug in UI
  if(keywordsArray.some(k=>k.slug === slug)) return alert('Slug already exists locally. Choose a different slug or remove first.');
  const newKeyword = { keyword: kw, slug: slug };
  try{
    // Save to Firestore using slug as doc id (as you were doing)
    await setDoc(doc(db,'keywords',slug), newKeyword);
    keywordsArray.push(newKeyword);
    keywordsArray.sort((a,b)=>b.keyword.length - a.keyword.length);
    updateKeywordDisplay(); renderModalList();
    el('newKeyword').value=''; el('newSlug').value='';
    log(`‚úÖ Added keyword "${kw}" ‚Üí /site/${slug}`);
  }catch(e){
    console.error(e); log('Error adding keyword: '+e.message);
  }
}

async function removeKeyword(i){
  const removed = keywordsArray.splice(i,1)[0];
  updateKeywordDisplay(); renderModalList();
  try{
    await updateDoc(doc(db,'keywords',removed.slug), { removed: true });
    log(`‚ùå Removed keyword "${removed.keyword}" (flagged removed in Firestore)`);
  }catch(e){
    console.warn('Could not mark removed in Firestore', e);
    log(`‚ùå Removed keyword "${removed.keyword}" locally (Firestore update failed)`);
  }
}

/* ============================
   Utility: escape regex & HTML
   ============================ */
function escapeRegExp(string){ return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
function escapeHtml(s){ return s.replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]) ); }

/* ============================
   DOM-safe replace logic
   - parse paragraph HTML
   - walk text nodes, skip inside <a>, <script>, <style>, <code>, <pre>
   - replace occurrences by inserting elements so HTML structure remains intact
   ============================ */
function shouldSkipNode(node){
  if(!node || !node.parentElement) return true;
  const skip = node.parentElement.closest('a,script,style,code,pre');
  return !!skip;
}

/**
 * Replace occurrences of regex in a text node with a DOM node (link or mark).
 * - regex must be global / case-insensitive if you want multiple in same node.
 * - createReplacement(text, matchText, targetSlug) returns a Node to insert
 */
function replaceInTextNode(node, regex, createReplacement, perNodeLimit=Infinity){
  if(!node || !node.nodeValue) return 0;
  if (shouldSkipNode(node)) return 0;
  const text = node.nodeValue;
  let match;
  let lastIndex = 0;
  const frag = document.createDocumentFragment();
  let count = 0;
  regex.lastIndex = 0;

  while((match = regex.exec(text)) !== null && count < perNodeLimit){
    const before = text.slice(lastIndex, match.index);
    if(before) frag.appendChild(document.createTextNode(before));
    // create replacement node
    frag.appendChild(createReplacement(match[0]));
    lastIndex = regex.lastIndex;
    count++;
    // prevent infinite loops for zero-length matches
    if(match.index === regex.lastIndex) regex.lastIndex++;
  }
  if(count === 0) return 0;
  const after = text.slice(lastIndex);
  if(after) frag.appendChild(document.createTextNode(after));
  node.parentNode.replaceChild(frag, node);
  return count;
}

/* ============================
   Process a single paragraph's HTML string:
   returns updated HTML and boolean whether changed
   ============================ */
async function processParagraphHtml(htmlString, pageSlug, perBlockLimit=2){
  // parse to DOM to avoid breaking tags
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div id="root">${htmlString}</div>`, 'text/html');
  const root = doc.getElementById('root');

  // Compute allowed replacements per paragraph
  let replacementsDone = 0;
  const perParagraphLimit = perBlockLimit;

  // iterate keywords: we try each keyword against the paragraph
  for(let kwObj of keywordsArray){
    if(replacementsDone >= perParagraphLimit) break;
    // skip if same-page target
    if(kwObj.slug === pageSlug) continue;
    // skip if block already contains the target path
    if(root.innerHTML.includes(`/site/${kwObj.slug}`)) continue;

    // build regex:
    // - match as phrase, case-insensitive, global
    // - allow word-boundaries but also match multi-word or hyphenated phrases
    // using simple approach: escape keyword and look for it bounded by either start/end or non-letter on either side
    const escaped = escapeRegExp(kwObj.keyword);
    const regex = new RegExp(`(${escaped})`, 'gi');

    // replacement factory: returns an element (<mark> for test, <a> for real)
    const createReplacement = (matchedText) => {
      if(testMode){
        const m = doc.createElement('mark');
        m.className = 'test-link';
        m.textContent = matchedText;
        return m;
      } else {
        const a = doc.createElement('a');
        a.className = 'inserted-link';
        a.href = `/site/${kwObj.slug}`;
        a.rel = 'noopener';
        a.textContent = matchedText;
        return a;
      }
    };

    // walk text nodes and replace up to remaining quota
    const walker = doc.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
    let node;
    while((node = walker.nextNode()) && replacementsDone < perParagraphLimit){
      // skip text nodes that are whitespace only
      if(!node.nodeValue.trim()) continue;
      const remainingForParagraph = perParagraphLimit - replacementsDone;
      const did = replaceInTextNode(node, regex, createReplacement, remainingForParagraph);
      replacementsDone += did;
      if(replacementsDone >= perParagraphLimit) break;
    }
  }

  const newHtml = root.innerHTML;
  const changed = (newHtml !== htmlString);
  return { html: newHtml, changed, replacementsDone };
}

/* ============================
   Auto-linking: process blocks array (your pages use blocks)
   ============================ */
async function autoLinkBlocks(blocks, pageSlug){
  if(!Array.isArray(blocks)) return blocks;
  // count words across paragraph blocks
  const paragraphBlocks = blocks.filter(b => b.type === 'paragraph' && b.html);
  const totalWords = paragraphBlocks
    .map(b => (b.html || '').replace(/<[^>]+>/g,'').split(/\s+/).filter(Boolean).length)
    .reduce((a,b)=>a+b,0);

  // densityFactor input controls words per link (lower = more links)
  const densityFactor = Math.max(50, parseInt(el('densityFactor').value,10) || 150);
  maxLinks = Math.max(1, Math.floor(totalWords / densityFactor));
  insertedLinks = 0;
  processedPages++;

  el('currentPage').innerText = pageSlug;
  updateStatsUI(totalWords);

  firstPreviewShown = false;
  // For each paragraph block, attempt to link it. Stop when insertedLinks >= maxLinks
  for(let i=0;i<blocks.length;i++){
    if(!autoLinkRunning || insertedLinks >= maxLinks) break;
    const b = blocks[i];
    if(b.type !== 'paragraph' || !b.html) continue;

    // show 'before' preview for first changed paragraph
    const before = b.html;
    const perBlockLimit = Math.max(1, parseInt(el('perBlockLimit').value,10) || 2);

    const result = await processParagraphHtml(b.html, pageSlug, perBlockLimit);
    if(result.changed){
      // apply replacements limited by remaining global quota
      const canApply = Math.min(result.replacementsDone, Math.max(0, maxLinks - insertedLinks));
      // If in test mode we already applied the highlights. In live mode, result.html contains <a> tags.
      // BUT processParagraphHtml applied up to perBlockLimit; ensure we don't exceed global max:
      // If we applied more than canApply, we need to post-process: but since processParagraphHtml stopped at perBlockLimit,
      // and we limit perBlockLimit & maxLinks appropriately, in practice this should be safe.
      blocks[i].html = result.html;
      insertedLinks += result.replacementsDone; // track global count
      // show preview for first change
      if(!firstPreviewShown){
        el('previewBeforeInner').innerHTML = before;
        el('previewAfterInner').innerHTML = result.html;
        firstPreviewShown = true;
      }
      log(`${testMode ? 'üü° Preview' : 'üîó Linked'} ‚Äî page:${pageSlug} | changed paragraph ${i} | +${result.replacementsDone} links`);
    }
    updateStatsUI(totalWords);
  }

  log(`Page "${pageSlug}" processed. Inserted so far: ${insertedLinks}/${maxLinks}`);
  return blocks;
}

/* ============================
   Page operations (single + all)
   ============================ */
async function updateSinglePage(pageId){
  try{
    const pageRef = doc(db,'pages',pageId);
    const snap = await getDoc(pageRef);
    if(!snap.exists()){ log(`‚ùå Page not found: ${pageId}`); return; }
    const d = snap.data();
    if(!d.blocks) { log(`‚ö†Ô∏è Page ${d.slug} has no blocks.`); return; }
    autoLinkRunning = true;
    const newBlocks = await autoLinkBlocks(d.blocks.slice(), d.slug);
    if(!testMode){
      await updateDoc(pageRef, { blocks: newBlocks });
      log(`‚úÖ Updated page: ${d.slug} (id:${pageId})`);
    } else {
      log(`üü° Previewed page: ${d.slug} (id:${pageId}) ‚Äî not saved (test mode)`);
    }
  }catch(e){
    console.error(e); log('Error updating page: '+e.message);
  }
}

async function runAutoLinkAll(){
  try{
    log('‚è≥ Loading pages...');
    const snap = await getDocs(collection(db,'pages'));
    if(snap.empty){ log('‚ùå No pages found.'); return; }
    processedPages = 0;
    for(const docSnap of snap.docs){
      if(!autoLinkRunning) break;
      const d = docSnap.data();
      if(!d.blocks) continue;
      await autoLinkBlocks(d.blocks, d.slug);
      if(!testMode){
        try{
          await updateDoc(doc(db,'pages',docSnap.id), { blocks: d.blocks });
          log(`‚úÖ Updated: ${d.slug}`);
        }catch(e){
          console.warn('Failed to save page', d.slug, e);
          log(`‚ö†Ô∏è Failed to save: ${d.slug}`);
        }
      } else {
        log(`üü° Previewed: ${d.slug}`);
      }
      processedPages++;
    }
    log(`üéâ Done! Processed ${processedPages} pages.`);
  }catch(e){
    console.error(e);
    log('Error during runAutoLinkAll: '+e.message);
  }
}

/* ============================
   Controls (expose to UI)
   ============================ */
function startAutoLink(){ if(autoLinkRunning) return log('Already running'); autoLinkRunning=true; runAutoLinkAll(); log('‚ñ∂ Auto-link started'); }
function stopAutoLink(){ autoLinkRunning=false; log('‚èπ Auto-link stopped'); }
function skipKeyword(){ // skip by rotating keywords: move first to end
  if(keywordsArray.length > 0){
    const moved = keywordsArray.shift();
    keywordsArray.push(moved);
    updateKeywordDisplay();
    log(`‚è≠ Skipped keyword "${moved.keyword}"`);
  } else log('No keywords to skip');
}
function toggleTestMode(){ testMode = !testMode; el('testModeStatus').innerText = testMode ? 'ON' : 'OFF'; log(`üîÄ Test Mode ${testMode ? 'ON' : 'OFF'}`); }

/* expose minimal functions */
window.startAutoLink = startAutoLink;
window.stopAutoLink = stopAutoLink;
window.skipKeyword = skipKeyword;
window.toggleTestMode = toggleTestMode;
window.updateCurrentPage = function(){ const pageId = el('pageIdInput').value.trim(); if(!pageId) return log('‚ö†Ô∏è Enter a page ID'); updateSinglePage(pageId); };
window.openKeywordModal = openKeywordModal;
window.closeKeywordModal = closeKeywordModal;
window.addKeyword = addKeyword;
window.removeKeyword = removeKeyword;
window.clearLog = clearLog;

/* load keywords on init */
loadKeywords();

</script>
</body>
</html>
